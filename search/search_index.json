{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Welcome to eBPF-MojitOS, a GitHub organization created as part of our university coursework. Our primary goal is to consolidate all our research and projects related to the development and application of eBPF technology. This initiative is specifically aimed at integrating these advancements into MOJITO/S, an Open Source System for Energy and Network Monitoring at the Operating System level. This project is being carried out in collaboration with the Institut de Recherche en Informatique de Toulouse (IRIT).</p>"},{"location":"#why-ebpf","title":"Why eBPF?","text":"<p>eBPF is a technology that enables dynamic tracing and monitoring of systems without needing to change kernel source code or load kernel modules. Its application in MojitOS is expected to enhance the system's capabilities in terms of performance monitoring and security features.</p> <p></p>"},{"location":"introduction/","title":"What is eBPF ?","text":"<p>eBPF, or extended Berkeley Packet Filter, is a technology that enables secure execution of code within the kernel of an operating system (Windows or Linux). Initially developed for network packet filtering, BPF evolved into eBPF to become a more general technology capable of injecting and executing more complex and diversified code.</p>"},{"location":"introduction/#operation","title":"Operation","text":""},{"location":"introduction/#ebpf-program-structure","title":"eBPF program structure","text":"<p>In most cases, the use of eBPF technology revolves around two types of programs:</p>"},{"location":"introduction/#user-space-program","title":"User-space program :","text":"<p>This is the code that runs in user space (outside the kernel). This program is responsible for managing and interacting with the eBPF code injected into the kernel. It can be used to inject/remove eBPF code, retrieve results via eBPF maps, etc.</p> <p>This part of the code is typically written in C, but APIs that allow the use of higher-level languages such as BCC (BPF Compile Collection, which uses Python) or eBPF-GO (which uses Go) can also be utilized. In C, some libraries exist to facilitate the writing of this part of the program, such as libbpf.</p>"},{"location":"introduction/#kernel-space-program","title":"Kernel space program :","text":"<p>This is the actual BPF code injected into the kernel. This code is often referred to as \"eBPF program\" or \"kernel space program.\" It can be dynamically injected into the kernel and executed in response to certain events, such as the arrival of network packets or the invocation of a system command by a process.</p> <p>In addition to being necessarily written in C, this part of the code is extremely constrained due to its execution within the kernel. For example:</p> <ul> <li>These programs cannot use uninitialized variables or access memory beyond limits.</li> <li>These programs must have a size allowing them to be injected into the kernel.</li> <li>They must have finite complexity.</li> <li>They must not be able to block in any way (infinite loops, etc.).</li> <li>The process injecting the eBPF code into the kernel must have the necessary privileges.</li> </ul> <p>These constraints are ensured to be respected by the eBPF verifier (see Compilation and Verification section).</p>"},{"location":"introduction/#compilation-and-verification","title":"Compilation and verification","text":"<p>The eBPF code requires certain operations before being injected into the kernel. The first step is to compile the file into bytecode (ELF format) because this is the file type expected by the kernel.</p> <p></p> <p>Clang and GCC (since version 10) support the compilation of eBPF files.</p> <p>Subsequently, the ELF file undergoes a verifier that ensures the program will run correctly within the kernel. The purpose is to guarantee the absence of potential crashes or program blockages during its execution and to ensure that there are no security vulnerabilities. Without this verification, running an eBPF program would be extremely risky.</p> <p></p> <p>The ELF file then goes through a Just-in-Time (JIT) compiler that transforms it into Assembly language instructions (specific to the machine architecture on which the file is located). Finally, the program is attached to the system event with which it has been associated.</p>"},{"location":"introduction/#ebpf-maps","title":"eBPF maps","text":"<p>eBPF maps are data structures used by eBPF programs. They primarily serve to store and share data between user space and kernel space, as well as between different instances of eBPF programs (other eBPF programs can access them, as well as programs outside the kernel through system calls). Since there can be concurrent access, map operations are atomic to preserve data coherence.</p> <p>Information is stored persistently, allowing access at any time.</p>"},{"location":"introduction/#events","title":"Events","text":"<p>Each eBPF program must be attached to an \"event\" within the kernel. When this \"event\" occurs, the eBPF program is executed. There are numerous events of different types:</p> <ul> <li> <p>eBPF programs can be attached to events related to the arrival and processing of network packets using the eXpress Data Path (XDP) subsystem. They can also be associated with events related to network traffic management.</p> </li> <li> <p>eBPF programs can be attached to specific locations in the kernel (tracepoints) to collect real-time information, allowing detailed analysis of system execution.</p> </li> <li> <p>eBPF programs can be attached to entry or exit points of kernel functions, enabling the creation of system probes (Kprobes) for debugging, monitoring, and other tasks.</p> </li> <li> <p>eBPF programs can be attached to the Linux Security Module (LSM) and influence the behavior of the kernel.</p> </li> <li> <p>and much more...</p> </li> </ul>"},{"location":"eBPF_programs/events/","title":"Events","text":"<p>IT WILL CONTAIN ALL EVENTS AVAILABLE AND RELEVANT TO THE PROJECT</p> <p>POSSIBLE :</p> <ul> <li>sysinfo : This system call is used by the '-m' option of Mojito/S to retrieve memory information. Two events are associated with it: sys_exit_sysinfo and sys_enter_sysinfo. They are enabled by default and are generated regularly by the system.</li> <li> <p>sched : To access scheduling infos</p> </li> <li> <p>vmalloc and kmalloc: To access memory allocations infos</p> </li> <li> <p>percpu : To access memory allocations info for cpu ( need to be verified )</p> </li> </ul> <p>IMPOSSIBLE : </p>"},{"location":"eBPF_programs/examples/","title":"Examples","text":""},{"location":"eBPF_programs/examples/#inter-process-communication","title":"Inter-process Communication","text":"<p>Attach a program to an XDP-event. Transformed C sources code into eBPF bytecode and then compiled to machine code. Load the program in the kernel and attach it to event.</p> <p>hello.bpf.c <pre><code>#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\nint counter = 0;\n\nSEC(\"xdp\")\nint hello(struct xdp_md *ctx) {\n    bpf_printk(\"Hello World %d\", counter);\n    counter++; \n    return XDP_PASS;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre></p> <p>hello-func.bpf.c</p> <pre><code>#include &lt;linux/bpf.h&gt;\n#include &lt;bpf/bpf_helpers.h&gt;\n\nstatic __attribute((noinline)) int get_opcode(struct bpf_raw_tracepoint_args *ctx) {\n    return ctx-&gt;args[1];\n}\n\nSEC(\"raw_tp/\")\nint hello(struct bpf_raw_tracepoint_args *ctx) {\n    int opcode = get_opcode(ctx);\n    bpf_printk(\"Syscall: %d\", opcode);\n    return 0;\n}\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <ul> <li> <p>Compilation in eBPF bytecode \\ make</p> </li> <li> <p>Loading the program in the kernel\\ sudo bpftool prog load hello.bpf.o /sys/fs/bpf/hello</p> </li> </ul> <p>(hello is the program's name)</p> <ul> <li> <p>Check if the program is in the kernel \\ ls /sys/fs/bpf</p> </li> <li> <p>Some information of the program \\ sudo bpftool prog list</p> </li> <li> <p>Attach the program to an event \\ sudo bpftool net attach xdp id 540 dev lo</p> </li> <li> <p>Check the output \\ sudo cat /sys/kernel/debug/tracing/trace_pipe</p> </li> <li> <p>Detach the program \\ sudo bpftool net detach xdp dev lo</p> </li> <li> <p>Remove the program to the kernel \\ sudo rm /sys/fs/bpf/hello</p> </li> </ul> <p>eBPF program :</p> <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n#include \"simple.h\"\n\nchar LICENSE[] SEC(\"license\") = \"GPL\";\n\n\nint count=0;\n\n\nstruct {\n    __uint(type, BPF_MAP_TYPE_HASH);\n    __uint(max_entries, 40000);\n    __type(key, u32);\n    __type(value, struct typetest);\n} my_map SEC(\".maps\");\n\n\n\nSEC(\"tp/signal/signal_deliver\")\nint test(void *params)\n{\n\n    struct typetest t;\n    t.pid =  bpf_get_current_pid_tgid() &gt;&gt; 32;\n    t.count = count;\n    t.uid = bpf_get_current_uid_gid() &amp; 0xFFFFFFFF;\n    if( ! bpf_map_lookup_elem(&amp;my_map,&amp;t.pid) ){\n        bpf_map_update_elem(&amp;my_map,&amp;t.pid,&amp;t,BPF_ANY);\n    }\n    count ++;\n    return 0;\n}\n</code></pre> <p>User space program :</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/resource.h&gt;\n#include &lt;unistd.h&gt;\n#include \"simple.h\"\n#include \"simple.skel.h\"\n\n\nvoid print_map_array(struct simple *skel){\n\n    struct typetest t;\n    int *cur_key= NULL;\n    int next_key;\n    int err;\n\n    if( (err = bpf_map__get_next_key(skel-&gt;maps.my_map, cur_key, &amp;next_key,sizeof(int)))==0){\n\n        printf(\"-----------------------------------------------------------------------------------\\n\");\n        for (;err == 0;) {\n\n                bpf_map__lookup_elem(skel-&gt;maps.my_map, &amp;next_key,sizeof(int), &amp;t,sizeof(struct typetest),BPF_ANY);\n                printf(\"PID = %d,  count = %d  , UID = %d\\n\",t.pid,t.count,t.uid);\n\n\n                cur_key = &amp;next_key;\n                err = bpf_map__get_next_key(skel-&gt;maps.my_map, cur_key, &amp;next_key,sizeof(int));\n        }\n        printf(\"-----------------------------------------------------------------------------------\\n\");\n    }\n}\n\nint main(void)\n{\n\n    struct simple *skel = simple__open();\n    simple__load(skel);\n    simple__attach(skel);\n\n\n    while(true){\n        sleep(1);\n        print_map_array(skel);\n    }\n\n    return 0;\n}\n</code></pre> <p>Marche bien mais je conseille de tester en changeant d'\u00e9v\u00e8nement</p> <ul> <li>structure de donn\u00e9es utilis\u00e9 ( \u00e0 mettre dans un .h ):</li> </ul> <pre><code>struct typetest {\n    int pid;\n    int count;\n    int uid;\n};\n</code></pre> <p>en gros, le programme affiche le contenu de la Hash-map toute les 1 seconde ( la Hash-map contient de \u00e9l\u00e9ments de type struct typeset)</p> <p>Pour utiliser un evenement du kernel, on peut aller voir la liste des evenements disponibles dans <pre><code>sudo cat /sys/kernel/debug/tracing/available_events\n</code></pre></p> <p>De la, on peut choisir l'evenement que l'on veut de la forme \"type d'evenement : evenement\" Ensuite, on peut modifier le code suivant pour utiliser l'evenement choisit :</p> <p>test.bpf.c <pre><code>#include \"vmlinux.h\"\n#include &lt;bpf/bpf_helpers.h&gt;\n#include &lt;bpf/bpf_tracing.h&gt;\n#include &lt;bpf/bpf_core_read.h&gt;\n\n\n\nstruct my_syscalls_enter_sysinfo{\n    unsigned short common_type;\n    unsigned char common_flags;\n    unsigned char common_preempt_count;\n    int common_pid;\n    int syscall_nr;\n    void *info;\n};\n\nSEC(\"tp/syscalls/sys_enter_sysinfo\")\nvoid testmdr(struct my_syscalls_enter_sysinfo *ctx){\n\n\n        bpf_printk(\"%d\\n\", ctx-&gt;common_pid);\n\n\n}\n\n\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre></p> <p>Nous devons remplacer SEC(tp/../..) par SEC(tp/type d'evenement/evenement) et remplacer la structure de donn\u00e9es pour qu'elle corresponde au format de l'\u00e9venement. Pour r\u00e9cup\u00e9rer le format de l'\u00e9venement il suffit de faire  <pre><code>sudo cat /sys/kernel/tracing/events/type_de_l'event/l'event en question/format\n</code></pre></p> <p>Ainsi s'affichera le format de la structure de donn\u00e9e de l'\u00e9venement.</p> <p>Quand les modifications sont faites, il suffit d'ajouter ces fichiers au dossier</p> <p>test.c <pre><code>#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;bpf/libbpf.h&gt;\n#include \"test.skel.h\"\n\n\n\n\nint main(void)\n{\n\n    struct test_bpf *skel = test_bpf__open();\n    test_bpf__load(skel);\n    test_bpf__attach(skel);\n\n\n    while(true){\n        sleep(1);\n    }\n\n    return 0;\n}\n</code></pre></p> <p>Makefile</p> <pre><code>BIN=\"test\"\n\nall:\n    @bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h\n    @clang -g -O3 -target bpf -D__TARGET_ARCH_x86 -c $(BIN).bpf.c -o $(BIN).bpf.o\n    @bpftool gen skeleton $(BIN).bpf.o &gt; $(BIN).skel.h\n    @clang $(BIN).c -lbpf -lelf -o $(BIN)\n\n.PHONY: clean\nclean:\n    @rm -rf *.o *.skel.h vmlinux.h $(BIN)\n</code></pre> <p>Il n'y a plus qu' compiler avec make, ce qui loadera le programme dans le kernel et attachera celui ci \u00e0 l'\u00e9venement souhait\u00e9. Il faut ensuite execcuter le programme et pour afficher les prints, il faut regarder dans le trace_pipe \u00e0 l'adresse  <pre><code>sudo cat /sys/kernel/tracing/trace_pipe\n</code></pre></p>"},{"location":"eBPF_programs/structure_ebpf_program/","title":"How to write eBPF program","text":"<p>This guide broadly explains how to create an eBPF program intended to be executed within the kernel. Given that eBPF technology is rapidly evolving and tools such as libbpf or bpftool are constantly being updated, this document may quickly become outdated</p>"},{"location":"eBPF_programs/structure_ebpf_program/#library","title":"Library","text":"<p>Various libraries can be used within eBPF programs, including:</p> <ul> <li> <p>bpf/bpf_helpers.h: provides the definitions of BPF helper functions.</p> </li> <li> <p>bpf/bpf_tracing.h: contains definitions for macros, helper functions, and data structures necessary for creating eBPF programs that focus on tracing system calls, kernel functions, and other events within the kernel.</p> </li> <li> <p>bpf/bpf_core_read.h: offers macros and helper functions to facilitate the secure reading of data from kernel space to a BPF program without triggering access violations.</p> </li> <li> <p>linux/bpf.h: provides basic definitions, constants, data structures, and function prototypes necessary for developing and interacting with BPF programs in the kernel space.</p> </li> </ul> <p>The use of the vmlinux.h file, which is an automatically generated header file containing definitions of data structures, symbols, and function prototypes extracted directly from the compiled Linux kernel, is highly recommended. if you want to use it, dont forget to add this command to your makefile  :</p> <pre><code>bpftool btf dump file /sys/kernel/btf/vmlinux format c &gt; vmlinux.h\n</code></pre> <p>At a minimum, you must include linux/bpf.h or vmlinux.h for your program to work.</p>"},{"location":"eBPF_programs/structure_ebpf_program/#maps","title":"Maps","text":"<p>Generally, maps are declared as follows:</p> <p></p> <ul> <li>type: the type of the map</li> <li>key: the index type used to access elements</li> <li>value: the type of elements stored in the map</li> <li>max_entries: the maximum number of elements that can be stored.</li> </ul> <p>A name is also associated with the map (here, \"my_octets\") and it is stored in the ELF \".maps\" section (which will be used by libbpf to access the map from the user-space program).</p> <p>The type of map greatly influences how eBPF maps are declared. Therefore, I invite you to consult the following page for more detailed explanations on the different types of maps and how to use them : https://www.kernel.org/doc/html/latest/bpf/maps.html</p>"},{"location":"eBPF_programs/structure_ebpf_program/#program-type","title":"Program type","text":"<p>The behavior of an eBPF program, as well as the helper functions that the eBPF program can access, are determined by the program type. Therefore, it is important to understand how this works.</p> <p>The type of eBPF programs is mostly specified just above the program's main function ( with SEC() ). The program is then associated with the ELF section bearing this name. This defines where the program can be attached and what type of data it will be able to act upon.</p> <p></p> <p>It's possible to specify the type of attachment ( event ) you want for our program depending on its type. The formats vary significantly depending on the program type. I invite you to consult the following page to get the complete list: https://www.kernel.org/doc/html/latest/bpf/libbpf/program_types.html#program-types-and-elf.</p> <p>The program type and the event also determines the type of \"context\" (the function parameters) that the main function receives (see the \"Functions\" section).</p>"},{"location":"eBPF_programs/structure_ebpf_program/#functions-and-context","title":"Functions and context","text":"<p>Functions are the core of eBPF programs as they contain all the code that will be executed when the event associated with the program is captured. Each program has a context, which depends on the program type and the event it is associated with. The context contains information about the captured event and is passed as a parameter to the main function. </p> <p></p> <p>Once again, the list of possible context types varies widely, and there is no site that lists them all. They are defined in different parts of the kernel headers. However, you can get an idea by visiting the following site: https://blogs.oracle.com/linux/post/bpf-a-tour-of-program-types</p> <p>You can also create functions ,structures and types ,as in any other program, which will be used in the main function. However, you have to assert that every potential error in any part of the ebpf program is handle. If its not the case, the eBPF verifier will not allow the code to run on the kernel. </p> <p>Don't forget to add the licence of your program like this:</p> <pre><code>char LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n</code></pre> <p>otherwise, the code will not work.</p>"},{"location":"eBPF_programs/structure_ebpf_program/#compilation","title":"Compilation","text":"<p>You can use Clang or GCC to do it. For example: </p> <pre><code>clang -target bpf -D __TARGET_ARCH_(your ARCH name) -Wall -O2 -g -c prog_name.c -o prog_name.o\n</code></pre> <ul> <li>-target is used to specified the type of program we try to compile. </li> <li>-D__TARGET_ARCH_(your ARCH name) is necessary if you use libraries such as bpf/bpf_tracing.h, because they contain types and structures based on elements specific to the system architecture, like registers, for example.</li> </ul>"},{"location":"eBPF_programs/structure_ebpf_program/#manipulate-the-program","title":"Manipulate the program","text":"<p>In this example, we use the tool bpftool.</p> <p>( This is the sequence of operations that need to be performed, but the commands themselves do not work. The parameters used by bpftool depend on the program type.\")</p> <p>First, we load the program into the kernel</p> <pre><code>sudo bpftool prog load prog_name.o /sys/fs/bpf/prog_name\n</code></pre> <p>then we retrieve its ID: </p> <pre><code>sudo bpftool prog list\n</code></pre> <p>and finally, we attach the program using its previously retrieved ID:</p> <pre><code>sudo bpftool prog attach id\n</code></pre> <p>to detach the program and remove it from the kernel:</p> <pre><code>sudo bpftool prog detach id\n</code></pre> <p>then</p> <pre><code>sudo rm /sys/fs/bpf/prog_name\n</code></pre> <p>To verify that the program is no longer in the kernel:</p> <pre><code>sudo bpftool prog show name prog_name\n</code></pre> <p>The whole set of these operations is quite tedious. It is possible to do otherwise by using a specific user space program to attach, detach, load, and remove the program using libbpf macros.</p> <p>I invite you to read the following documentations to learn about the libbpf macros and understand the concept of \"skeleton\" :</p> <ul> <li> <p>https://libbpf.readthedocs.io/en/latest/api.html </p> </li> <li> <p>https://www.kernel.org/doc/html/latest/bpf/libbpf/libbpf_overview.html</p> </li> </ul>"},{"location":"installation/linux/","title":"Linux eBPF installation guide","text":"<p>This guide provides an overview of the installation of libbpf and bpftool, whiwh are tools for eBPF. We also need clang/llvm to compile eBPF code.</p>"},{"location":"installation/linux/#installing-dependencies-for-bpftool","title":"Installing dependencies for bpftool","text":"<p>First of all, make sure your system is already updated with the following command: <pre><code>sudo apt-get update -y\n</code></pre></p> <p>Now, we have to install some packages needed by bpftool. We need <code>libelf-dev</code>, <code>zlib</code>, <code>libbfd-dev</code>, <code>libcap-dev</code>, <code>libbpf-dev</code> and <code>llvm</code> package.</p> <pre><code>sudo apt-get install -y zlib1g-dev libelf-dev libbfd-dev libcap-dev libbpf-dev llvm\n</code></pre> <p>On Ubuntu distributions, clang is basically installed but if it's not, you can install it with <pre><code>sudo apt install clang\n</code></pre></p>"},{"location":"installation/linux/#installing-bpftool-and-libbpf","title":"Installing bpftool and libbpf","text":"<p>Now, you can install bpftool without any stress. You just have to clone the bpftool repository, compile, and install it with :</p> <pre><code>git clone --recurse-submodules https://github.com/libbpf/bpftool.git\ncd bpftool/src\nsudo make install\n</code></pre> <p>Your installation should be complete, and you can now compile BPF code. </p>"},{"location":"installation/linux/#problem-with-the-location-of-shared-library","title":"Problem with the location of shared library","text":"<p>If you try to execute your code, you will see this issue : <pre><code>sudo ./simple\n./simple: error while loading shared libraries: libbpf.so.1: cannot open shared object file: No such file or directory\n</code></pre></p> <p>If this issue occurs, you just need to tell the opearting system where it can locate it at runtime.</p> <p>To do so, we will need to execute those command:</p> <p><pre><code>sudo find / -name libbpf.so.1\n</code></pre> To find where the library is placed if you dont know it <pre><code>sudo ldconfig my_path\n</code></pre> Where <code>my_path</code> is the path for the file libbpf.so.1</p> <p>With that if you try to execute your code, it will work. Otherwise, you can look at this forum to see if your problem is resolved : - https://stackoverflow.com/questions/480764/linux-error-while-loading-shared-libraries-cannot-open-shared-object-file-no-s</p> <p>Congratulation, now you can make and execute instructions and code to use eBPF technology. </p>"},{"location":"installation/wsl2/","title":"WSL2 Installation Guide","text":"<p>Warning</p> <p>This guide is not exhaustive, and making modifications to the WSL kernel may lead to system instability, data corruption, and other potential issues. Proceed with caution and back up your data before attempting any changes.</p> <p>Installing the eBPF technology along with essential tools such as bcc, bpftool, bpftrace, clang, and llvm on WSL2 can be a complex and time-consuming process. This guide provides a step-by-step overview of the installation process, explaining the purpose of each tool.</p>"},{"location":"installation/wsl2/#compiling-the-wsl-kernel-and-obtaining-necessary-headers","title":"Compiling the WSL Kernel and Obtaining Necessary Headers","text":"<p>On WSL2, certain dependencies and packages required for this installation are not readily available through <code>apt-get</code>. the <code>linux-headers-$(uname -r)</code> package is not available through standard package managers like <code>apt-get</code>. Therefore, manual kernel compilation is necessary to generate the required headers for eBPF.</p> <pre><code>[23:47:05] [~/master_info/eBPF] \u2771\u2771\u2771 sudo apt-get install linux-headers-$(uname -r)\n[sudo] password for dwayne:\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nE: Unable to locate package linux-headers-6.1.21.2-microsoft-standard-WSL2\nE: Couldn't find any package by glob 'linux-headers-6.1.21.2-microsoft-standard-WSL2'\nE: Couldn't find any package by regex 'linux-headers-6.1.21.2-microsoft-standard-WSL2'\n</code></pre> <p>Kernel headers are essential files that contain information about functions, structures, and constants used in the Linux kernel. They are crucial for building and compiling kernel modules, which are required for eBPF.</p> <p>Our objective is to compile the WSL kernel from source to generate the necessary header files for eBPF. Additionally, while eBPF has been available since kernel version 3.15, I recommend updating your kernel if it is too old to ensure full eBPF functionality. It's essential to be aware that eBPF features and tools may have evolved over time, and some features may require a more recent kernel version to work optimally.</p> <p>Tip</p> <p>You can refer to the official bcc documentation for specific details on which kernel versions support various eBPF features.</p> <p>In my case, I chose to install the latest available Microsoft Linux kernel, which is version 6. This ensures that I have access to all the latest eBPF capabilities and toolsets, providing a more robust and up-to-date development environment.</p> <ol> <li> <p>Clone the Microsoft Linux kernel repository from GitHub and switch to the kernel branch corresponding to version 6 (or desired kernel version)</p> <pre><code>git clone https://github.com/microsoft/WSL2-Linux-Kernel.git --depth=1 -b linux-msft-wsl-6.1.y\n</code></pre> </li> <li> <p>Install the necessary packages required for kernel compilation</p> <pre><code>sudo apt update &amp;&amp; sudo apt install build-essential flex bison libssl-dev libelf-dev\n</code></pre> </li> <li> <p>Compile the kernel. This process may take some time</p> <pre><code>cd WSL2-Linux-Kernel\n\n# Copy the WSL-specific configuration\ncp Microsoft/config-wsl .config\n\n# Compile the kernel with multiple cores for efficiency\nLOCALVERSION= make -j$(nproc)\n\n# Install kernel modules\nsudo LOCALVERSION= make KCONFIG_CONFIG=Microsoft/config-wsl modules_install -j$(nproc)\n\n# Install kernel headers\nsudo make headers_install ARCH=x86_64 INSTALL_HDR_PATH=/usr\n\n# Copy the compiled kernel image to a Windows-accessible location\ncp arch/x86/boot/bzImage /mnt/c/\n</code></pre> </li> <li> <p>After the installation, verify that the kernel modules are correctly present</p> <pre><code>[22:55:39] [~] \u2771\u2771\u2771 ls /lib/modules\n6.1.21.2-microsoft-standard-WSL2\n</code></pre> </li> </ol>"},{"location":"installation/wsl2/#configuring-wsl2-for-the-new-kernel","title":"Configuring WSL2 for the New Kernel","text":"<ol> <li> <p>Close the Terminal</p> <p>Ensure you've closed your current terminal.</p> </li> <li> <p>Create or Edit the WSL Configuration File</p> <p>On your Windows host machine, create or edit the file <code>%USERPROFILE%\\.wslconfig</code> with the following content</p> <pre><code>[wsl2]\nkernel=C:\\\\bzImage\n</code></pre> </li> <li> <p>Stop the WSL Instance</p> <p>Open PowerShell as Administrator, execute the following command to stop the WSL instance</p> <pre><code>wsl --shutdown\n</code></pre> </li> <li> <p>Check the Kernel Version</p> <p>After restarting your WSL instance, you can verify the kernel version with the following command. This command should confirm that you are now using the specified kernel image (<code>C:\\\\bzImage</code>) in your WSL2 environment</p> <pre><code>uname -r\n</code></pre> <p>Note</p> <p>If you encounter a \"No such file or directory\" error when trying to access '/sys/kernel/debug/tracing/', you can resolve this issue by running the following command:</p> <pre><code>mount -t debugfs none /sys/kernel/debug/\n</code></pre> <p>This command mounts the debug filesystem (<code>debugfs</code>) to the '/sys/kernel/debug/' directory, enabling proper access to debugging information required for working with eBPF and other tracing tools. Once this command is executed, you should be able to access debugging features without encountering the error.</p> </li> </ol>"},{"location":"installation/wsl2/#test-with-bpftrace","title":"Test with bpftrace","text":"<p>Let's proceed with your first attempt using BPF. You can use bpftrace to test and trace events. Bpftrace is a tool that builds a simplified tracing language on top of eBPF and BCC, allowing you to implement complex tracing functions with just a few lines of simple scripts.</p> <ol> <li> <p>Install bpftrace using the following command</p> <pre><code>sudo apt-get install bpftrace\n</code></pre> </li> <li> <p>Listing All Kernel Instruments and Tracepoints</p> <p>You can query all kernel instruments and tracepoints using the following command. </p> <pre><code>sudo bpftrace -l\n</code></pre> <p>This command will provide a list of available tracing points and instruments in the kernel, allowing you to choose the events you want to trace.</p> </li> <li> <p>Using bpftrace to Trace System Call Execution and Display Input Parameters</p> <p>To track the execution of a system call and display its input parameters, you can use the following bpftrace script</p> <pre><code>sudo bpftrace -e 'tracepoint:syscalls:sys_enter_execve {join(args-&gt;argv);}'\n</code></pre> <p>This script will trace the <code>execve</code> system call and display its input arguments, providing insights into the executed processes and their parameters.</p> </li> </ol>"},{"location":"installation/wsl2/#bpftool-and-libbpf","title":"bpftool and libbpf","text":"<p>Let's proceed with the installation of bpftool and libbpf, along with the necessary dependencies such as libbfd, clang, llvm, and libcap.</p>"},{"location":"installation/wsl2/#installing-llvm-and-clang","title":"Installing llvm and clang","text":"<p>First, let's install the latest versions of llvm and clang. Please note that these commands allow you to install all available versions of clang and llvm. It's not necessary to install all of them. </p> <p>Tip</p> <p>You can refer to Automatic installation script if you want to install a specific version directly.</p> <pre><code>wget https://apt.llvm.org/llvm.sh\nsudo bash ./llvm.sh all\n</code></pre> <p>Next, we'll define the latest version of clang and llvm using the <code>update-alternatives</code> method. We'll use version 17. You can use the provided script for this purpose:</p> update-alternatives-clang.sh<pre><code>#!/usr/bin/env bash\n\n#     --slave /usr/bin/$1 $1 /usr/bin/$1-\\${version} \\\\\n\nfunction register_clang_version {\n    local version=$1\n    local priority=$2\n\n    update-alternatives \\\n        --verbose \\\n        --install /usr/bin/llvm-config          llvm-config          /usr/bin/llvm-config-${version} ${priority} \\\n        --slave   /usr/bin/llvm-ar              llvm-ar              /usr/bin/llvm-ar-${version} \\\n        --slave   /usr/bin/llvm-as              llvm-as              /usr/bin/llvm-as-${version} \\\n        --slave   /usr/bin/llvm-bcanalyzer      llvm-bcanalyzer      /usr/bin/llvm-bcanalyzer-${version} \\\n        --slave   /usr/bin/llvm-c-test          llvm-c-test          /usr/bin/llvm-c-test-${version} \\\n        --slave   /usr/bin/llvm-cat             llvm-cat             /usr/bin/llvm-cat-${version} \\\n        --slave   /usr/bin/llvm-cfi-verify      llvm-cfi-verify      /usr/bin/llvm-cfi-verify-${version} \\\n        --slave   /usr/bin/llvm-cov             llvm-cov             /usr/bin/llvm-cov-${version} \\\n        --slave   /usr/bin/llvm-cvtres          llvm-cvtres          /usr/bin/llvm-cvtres-${version} \\\n        --slave   /usr/bin/llvm-cxxdump         llvm-cxxdump         /usr/bin/llvm-cxxdump-${version} \\\n        --slave   /usr/bin/llvm-cxxfilt         llvm-cxxfilt         /usr/bin/llvm-cxxfilt-${version} \\\n        --slave   /usr/bin/llvm-diff            llvm-diff            /usr/bin/llvm-diff-${version} \\\n        --slave   /usr/bin/llvm-dis             llvm-dis             /usr/bin/llvm-dis-${version} \\\n        --slave   /usr/bin/llvm-dlltool         llvm-dlltool         /usr/bin/llvm-dlltool-${version} \\\n        --slave   /usr/bin/llvm-dwarfdump       llvm-dwarfdump       /usr/bin/llvm-dwarfdump-${version} \\\n        --slave   /usr/bin/llvm-dwp             llvm-dwp             /usr/bin/llvm-dwp-${version} \\\n        --slave   /usr/bin/llvm-exegesis        llvm-exegesis        /usr/bin/llvm-exegesis-${version} \\\n        --slave   /usr/bin/llvm-extract         llvm-extract         /usr/bin/llvm-extract-${version} \\\n        --slave   /usr/bin/llvm-lib             llvm-lib             /usr/bin/llvm-lib-${version} \\\n        --slave   /usr/bin/llvm-link            llvm-link            /usr/bin/llvm-link-${version} \\\n        --slave   /usr/bin/llvm-lto             llvm-lto             /usr/bin/llvm-lto-${version} \\\n        --slave   /usr/bin/llvm-lto2            llvm-lto2            /usr/bin/llvm-lto2-${version} \\\n        --slave   /usr/bin/llvm-mc              llvm-mc              /usr/bin/llvm-mc-${version} \\\n        --slave   /usr/bin/llvm-mca             llvm-mca             /usr/bin/llvm-mca-${version} \\\n        --slave   /usr/bin/llvm-modextract      llvm-modextract      /usr/bin/llvm-modextract-${version} \\\n        --slave   /usr/bin/llvm-mt              llvm-mt              /usr/bin/llvm-mt-${version} \\\n        --slave   /usr/bin/llvm-nm              llvm-nm              /usr/bin/llvm-nm-${version} \\\n        --slave   /usr/bin/llvm-objcopy         llvm-objcopy         /usr/bin/llvm-objcopy-${version} \\\n        --slave   /usr/bin/llvm-objdump         llvm-objdump         /usr/bin/llvm-objdump-${version} \\\n        --slave   /usr/bin/llvm-opt-report      llvm-opt-report      /usr/bin/llvm-opt-report-${version} \\\n        --slave   /usr/bin/llvm-pdbutil         llvm-pdbutil         /usr/bin/llvm-pdbutil-${version} \\\n        --slave   /usr/bin/llvm-PerfectShuffle  llvm-PerfectShuffle  /usr/bin/llvm-PerfectShuffle-${version} \\\n        --slave   /usr/bin/llvm-profdata        llvm-profdata        /usr/bin/llvm-profdata-${version} \\\n        --slave   /usr/bin/llvm-ranlib          llvm-ranlib          /usr/bin/llvm-ranlib-${version} \\\n        --slave   /usr/bin/llvm-rc              llvm-rc              /usr/bin/llvm-rc-${version} \\\n        --slave   /usr/bin/llvm-readelf         llvm-readelf         /usr/bin/llvm-readelf-${version} \\\n        --slave   /usr/bin/llvm-readobj         llvm-readobj         /usr/bin/llvm-readobj-${version} \\\n        --slave   /usr/bin/llvm-rtdyld          llvm-rtdyld          /usr/bin/llvm-rtdyld-${version} \\\n        --slave   /usr/bin/llvm-size            llvm-size            /usr/bin/llvm-size-${version} \\\n        --slave   /usr/bin/llvm-split           llvm-split           /usr/bin/llvm-split-${version} \\\n        --slave   /usr/bin/llvm-stress          llvm-stress          /usr/bin/llvm-stress-${version} \\\n        --slave   /usr/bin/llvm-strings         llvm-strings         /usr/bin/llvm-strings-${version} \\\n        --slave   /usr/bin/llvm-strip           llvm-strip           /usr/bin/llvm-strip-${version} \\\n        --slave   /usr/bin/llvm-symbolizer      llvm-symbolizer      /usr/bin/llvm-symbolizer-${version} \\\n        --slave   /usr/bin/llvm-tblgen          llvm-tblgen          /usr/bin/llvm-tblgen-${version} \\\n        --slave   /usr/bin/llvm-undname         llvm-undname         /usr/bin/llvm-undname-${version} \\\n        --slave   /usr/bin/llvm-xray            llvm-xray            /usr/bin/llvm-xray-${version}\n\n\n    update-alternatives \\\n        --verbose \\\n        --install /usr/bin/clang                    clang                   /usr/bin/clang-${version} ${priority} \\\n        --slave   /usr/bin/clang++                  clang++                 /usr/bin/clang++-${version}  \\\n        --slave   /usr/bin/clang-format             clang-format            /usr/bin/clang-format-${version}  \\\n        --slave   /usr/bin/clang-cpp                clang-cpp               /usr/bin/clang-cpp-${version} \\\n        --slave   /usr/bin/asan_symbolize           asan_symbolize          /usr/bin/asan_symbolize-${version} \\\n        --slave   /usr/bin/bugpoint                 bugpoint                /usr/bin/bugpoint-${version} \\\n        --slave   /usr/bin/dsymutil                 dsymutil                /usr/bin/dsymutil-${version} \\\n        --slave   /usr/bin/lld                      lld                     /usr/bin/lld-${version} \\\n        --slave   /usr/bin/ld.lld                   ld.lld                  /usr/bin/ld.lld-${version} \\\n        --slave   /usr/bin/lld-link                 lld-link                /usr/bin/lld-link-${version} \\\n        --slave   /usr/bin/llc                      llc                     /usr/bin/llc-${version} \\\n        --slave   /usr/bin/lli                      lli                     /usr/bin/lli-${version} \\\n        --slave   /usr/bin/obj2yaml                 obj2yaml                /usr/bin/obj2yaml-${version} \\\n        --slave   /usr/bin/opt                      opt                     /usr/bin/opt-${version} \\\n        --slave   /usr/bin/sanstats                 sanstats                /usr/bin/sanstats-${version} \\\n        --slave   /usr/bin/verify-uselistorder      verify-uselistorder     /usr/bin/verify-uselistorder-${version} \\\n        --slave   /usr/bin/wasm-ld                  wasm-ld                 /usr/bin/wasm-ld-${version} \\\n        --slave   /usr/bin/yaml2obj                 yaml2obj                    /usr/bin/yaml2obj-${version}\n\n}\n\nregister_clang_version $1 $2\n</code></pre> <pre><code>sudo bash ./update-alternatives-clang.sh 17 100\n</code></pre> <p>After running the script, clang and llvm should be properly set up. You can check their versions using the following commands:</p> <pre><code>clang --version\nllvm-strip --version\n</code></pre>"},{"location":"installation/wsl2/#installing-libcap-and-libbfd","title":"Installing libcap and libbfd","text":"<p>Now, let's install libcap and libbfd along with their development packages</p> <pre><code>sudo apt-get install -y libcap-dev libbfd-dev\n</code></pre>"},{"location":"installation/wsl2/#installing-libbpf","title":"Installing libbpf","text":"<p>We also need to install libbpf</p> <pre><code>sudo apt-get install libbpf-dev\n</code></pre> <p>In case you encounter issues with this library, you may need to compile and install it manually. To do so, follow these steps</p> <pre><code>git clone https://github.com/libbpf/libbpf.git\ncd ./libbpf/src\nmake\nsudo make install\n</code></pre>"},{"location":"installation/wsl2/#installing-bpftool","title":"Installing bpftool","text":"<p>Finally, to install bpftool, we need to compile and install it.  (i.e., during the build, all four dependencies should be green)</p> <pre><code>git clone --recurse-submodules https://github.com/libbpf/bpftool.git\ncd src\nmake\nsudo make install\n</code></pre> <p>Congratulations! Your installation should now be complete, and you can start developing with in Python with BCC and C using bpftool.</p> <ul> <li>https://learn.microsoft.com/en-us/community/content/wsl-user-msft-kernel-v6</li> <li>https://gist.github.com/junkdog/70231d6953592cd6f27def59fe19e50d</li> <li>https://www.cnblogs.com/hartmon/p/15935212.html</li> <li>https://github.com/microsoft/WSL2-Linux-Kernel</li> <li>https://github.com/libbpf/libbpf/</li> <li>https://github.com/iovisor/bcc/blob/master/INSTALL.md#wslwindows-subsystem-for-linux---binary</li> <li>https://apt.llvm.org/</li> <li>https://oftime.net/2021/01/16/win-bpf/</li> <li>https://blog.csdn.net/sinat_22338935/article/details/123002910</li> <li>https://blog.csdn.net/sinat_22338935/article/details/123005213</li> </ul>"}]}